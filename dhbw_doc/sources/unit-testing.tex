\documentclass[12pt]{article}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{inconsolata}
\usepackage{color}
\usepackage{enumitem}
\usepackage[a4paper, left=2.5cm, right=2.5cm, top=2.5cm]{geometry}
\usepackage[onehalfspacing]{setspace}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\usepackage{listings}
\lstset{language=Java,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\ttfamily,
  moredelim=[il][\textcolor{pgrey}]{$$},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}

\title{Unit Testing}
\date{DHBW Karlsruhe\\ Vorlesung Advanced Software Engineering Semester 5/6}
\author{Lukas Panni \\ TINF18B5}
\begin{document}
\maketitle

\newpage
\tableofcontents
\newpage


\section{Analyse und Begründung für Umfang der Tests}

Um die Funktionalität der einzelnen Komponenten gewährleisten zu können werden Unit-Tests eingesetzt.
Dabei werden für die einzelnen Tests nur die, für diesen Test, relevanten Teile des Systems verwendet.
Da Abhängigkeiten zu anderen Komponenten die Tests nicht beeinflussen sollen werden alle anderen Komponenten durch Fake-/Mock-Objekte ersetzt.
Das Zusammenspiel mit den anderen Komponenten kann in Integrationstests getestet werden.
Außerdem tragen Unit-Tests auch zur Dokumentation bei, indem das gewünschte Verhalten der Komponente für Regel- und Ausnahmefälle in den Testfällen dokumentiert ist.
\newline
Für dieses Projekt wird \textit{JUnit} als Framework für die Erstellung und Ausführung von Java-Unit-Tests verwendet.
Bei der Implementierung der Tests wurde darauf geachtet die ATRIP-Regeln (\textit{Automatic, Thorough, Repeatable, Independent, Professional}) möglichst zu beachten.
\newline
Teile des Codes in diesem Projekt werden für Android-Spezifische UI-Aufgaben benötigt und können nur schlecht getestet werden. Das führt auch dazu, dass die Code-Coverage über das gesamte Projekt vergleichsweise klein sein kann. Stattdessen sollte hier zur Beurteilung der Testabdeckung nur die Code-Coverage der anderen Klassen betrachtet werden.
\newline
Allgemein wird darauf verzichtet triviale Funktionen, wie zum Beispiel Getter zu testen.
Tests dieser Funktionen würden bei großem Aufwand nur einen minimalen Mehrwert bringen, da keine echte Funktionalität getestet wird.
Stattdessen sollen sich die Tests auf relevante Funktionalität des Systems fokussieren. Das bedeutet auch, dass vor allem die Klassen getestet werden sollen, die häufig verwendet werden.
\newline
Zum Beispiel werden in diesem System oft Konvertierungen von API-Datentypen zu Datentypen der Anwendung durchgeführt.
Diese Konvertierungen werden meist in den Konstruktoren der jeweiligen Anwendungsdatentypen durchgeführt.
Deshalb werden diese ausführlich getestet, wobei auch dabei auf Tests trivialer Funktionalität verzichtet wird.



\newpage
\section{Analyse und Begründung für Einsatz von Fake-/Mock-Objekten}

Fake- und Mock-Objekte werden benötigt, um Abhängigkeiten einer Komponente zu anderen Komponenten in Unit-Tests zu reduzieren.
Sie implementieren dafür zum Beispiel das benötigte Interface, aber davon nur die aktuell benötigte Funktionalität.


\end{document}